#!/usr/bin/env python3
"""
Generate buildinfo.cpp from git metadata.

This script is called by PlatformIO's pre: extra_scripts or by CI.
It extracts version info from git tags (vX.Y.Z format) and writes
the buildinfo.cpp file with actual values.

Usage:
    python scripts/generate_buildinfo.py [--output lib/version/buildinfo.cpp]

For PlatformIO integration, add to platformio.ini:
    extra_scripts = pre:scripts/generate_buildinfo.py
"""

import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path

# Template for buildinfo.cpp
TEMPLATE = '''/*
 * Build information - auto-generated by scripts/generate_buildinfo.py
 * Generated: {build_date}
 */

#include "buildinfo.h"

namespace BuildInfo {{

const char* version = "{version}";
const char* gitSha = "{git_sha}";
const char* gitShortSha = "{git_short_sha}";
const char* gitBranch = "{git_branch}";
const char* buildDate = "{build_date}";
const bool isRelease = {is_release};
const int versionMajor = {version_major};
const int versionMinor = {version_minor};
const int versionPatch = {version_patch};

}}  // namespace BuildInfo
'''


def run_git(args: list[str]) -> str:
    """Run a git command and return output, or empty string on failure."""
    try:
        result = subprocess.run(
            ["git"] + args,
            capture_output=True,
            text=True,
            timeout=5,
        )
        return result.stdout.strip() if result.returncode == 0 else ""
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return ""


def get_version_from_tag() -> tuple[str, int, int, int, bool]:
    """
    Get version from git tag.
    Returns (version_str, major, minor, patch, is_release).
    """
    # Try to get a tag pointing to current commit
    tag = run_git(["describe", "--tags", "--exact-match", "HEAD"])

    if tag and re.match(r"^v?\d+\.\d+\.\d+", tag):
        # We're on a tagged release
        version_str = tag.lstrip("v")
        match = re.match(r"(\d+)\.(\d+)\.(\d+)", version_str)
        if match:
            return (
                version_str,
                int(match.group(1)),
                int(match.group(2)),
                int(match.group(3)),
                True,
            )

    # Not on a release tag - use describe for dev version
    describe = run_git(["describe", "--tags", "--always"])
    if describe:
        # Parse vX.Y.Z-N-gSHORTSHA format
        match = re.match(r"v?(\d+)\.(\d+)\.(\d+)(?:-(\d+)-g([a-f0-9]+))?", describe)
        if match:
            major, minor, patch = int(match.group(1)), int(match.group(2)), int(match.group(3))
            commits_ahead = match.group(4)
            if commits_ahead:
                # Development build: bump patch and add -dev
                return (f"{major}.{minor}.{patch + 1}-dev+{commits_ahead}", major, minor, patch + 1, False)
            else:
                # Exact tag match
                return (f"{major}.{minor}.{patch}", major, minor, patch, True)

    # Fallback: no tags, use 0.0.0-dev
    return ("0.0.0-dev", 0, 0, 0, False)


def generate_buildinfo(output_path: Path) -> None:
    """Generate buildinfo.cpp with current git metadata."""
    # Get git info
    git_sha = run_git(["rev-parse", "HEAD"]) or "unknown"
    git_short_sha = git_sha[:7] if git_sha != "unknown" else "unknown"
    git_branch = run_git(["rev-parse", "--abbrev-ref", "HEAD"]) or "unknown"
    build_date = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    version_str, major, minor, patch, is_release = get_version_from_tag()

    content = TEMPLATE.format(
        version=version_str,
        git_sha=git_sha,
        git_short_sha=git_short_sha,
        git_branch=git_branch,
        build_date=build_date,
        is_release="true" if is_release else "false",
        version_major=major,
        version_minor=minor,
        version_patch=patch,
    )

    # Only write if content changed (to avoid unnecessary rebuilds)
    if output_path.exists():
        existing = output_path.read_text()
        # Compare ignoring build_date line
        def strip_date(s):
            return re.sub(r'buildDate = "[^"]*"', 'buildDate = ""', s)
        if strip_date(existing) == strip_date(content):
            print(f"buildinfo.cpp unchanged (version {version_str})")
            return

    output_path.write_text(content)
    print(f"Generated buildinfo.cpp: version={version_str} sha={git_short_sha}")


def main():
    # Find project root (where platformio.ini is)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # Default output path
    output_path = project_root / "lib" / "version" / "buildinfo.cpp"

    # Parse command line args
    if len(sys.argv) > 2 and sys.argv[1] == "--output":
        output_path = Path(sys.argv[2])

    generate_buildinfo(output_path)


# PlatformIO pre-build hook
def before_build(source, target, env):
    """Called by PlatformIO before build."""
    project_dir = Path(env.get("PROJECT_DIR", "."))
    output_path = project_dir / "lib" / "version" / "buildinfo.cpp"
    generate_buildinfo(output_path)


# Import for PlatformIO hook
try:
    Import("env")  # type: ignore
    env.AddPreAction("buildprog", before_build)  # type: ignore
except NameError:
    # Not running under PlatformIO
    if __name__ == "__main__":
        main()
